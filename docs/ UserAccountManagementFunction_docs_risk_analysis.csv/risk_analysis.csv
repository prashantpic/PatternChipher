risk_id,risk_category,risk_description,probability,impact,risk_score,priority_level,affected_tasks,root_cause,mitigation_strategy,contingency_plan,monitoring_trigger,owner,due_date,status
RISK-001,Technical,"Incomplete data deletion if all user-related collections are not identified. The current design only explicitly handles 'UserProfiles' and 'LeaderboardEntries', potentially leaving orphaned data in other collections (e.g., 'AchievementStatus') and causing a compliance failure.",4,5,20,High,"WI-007, WI-009, WI-015","Incomplete analysis of the full data model and its relationship with the user UID. Assumptions made based on examples in the SDS.",Preventive: Conduct a mandatory, thorough audit of the entire Firestore schema to identify every collection that stores a `userId` or `uid`. This audit must be a prerequisite for signing off on WI-007. Document all identified collections in the adapter's code.,Corrective: If an omission is discovered post-deployment, an emergency patch must be deployed to the function. A separate cleanup script must be written and run to find and delete the orphaned data for all users who have already used the deletion feature.,Completion of WI-007 without a documented schema audit attached to the pull request.,Dev Lead,2024-09-15,Open
RISK-002,Operational,"A failure in the final step (Auth deletion) after the initial step (Firestore deletion) succeeds leaves the system in an inconsistent state. The user has an authentication record but no corresponding data, which could lead to application crashes or unexpected behavior on subsequent login attempts.",3,5,15,High,"WI-008, WI-009, WI-010","The process is not atomic across separate services (Firestore, Auth). A transient error or permission issue in the second step can break the workflow after the first step is already committed.",Preventive: Make the entire process idempotent. The Auth adapter already gracefully handles 'user-not-found' errors. The service should log any other error from the Auth adapter critically and trigger an alert. The client app should be designed to handle a login from a user with an auth record but no firestore profile (e.g., by re-triggering deletion).,Corrective: Create a scheduled maintenance function or admin script to periodically query for Auth users who lack a corresponding `UserProfiles` document and delete them.,A CloudWatch/Google Cloud Operations alert fires for an error in the `deleteUser` function, specifically after the Firestore deletion log and before the Auth deletion success log.,Dev Lead,2024-09-20,Open
RISK-003,Compliance,"User's UID, which can be considered PII under GDPR, is logged in plain text for debugging purposes. If log retention policies are long, this could lead to a compliance violation.",4,4,16,High,"WI-005, WI-007, WI-008, WI-010","Need for detailed logs for debugging purposes clashing with data privacy requirements to minimize PII storage.",Preventive: In production environments, either anonymize the UID before logging (e.g., using a salted hash) or remove it entirely from log messages, relying on the function's execution ID for correlation. Log verbosity should be configurable per environment.,Corrective: If a compliance audit requires it, create and execute a script to purge the PII from historical logs using the cloud provider's logging API or BQ queries if logs are exported.,Review of production log output shows plain-text UIDs being stored.,Dev Lead,2024-09-12,Open
RISK-004,Security,"The authorization logic in the handler is incomplete. It correctly checks for self-deletion but the code explicitly notes that an admin-role check is omitted, creating a significant security risk if the function is ever intended to be used by a support tool without this check being added.",5,3,15,High,WI-010,"A known feature (admin-level deletion) was intentionally deferred for simplicity, creating a gap in the security model.",Preventive: Implement the admin role check using Firebase Auth custom claims as part of the initial development. The authorization logic should be `if (!isSelfDelete && !context.auth.token.admin)`. This should not be optional.,Corrective: If deployed without this, immediately restrict function invocation permissions in GCP to prevent any non-client access until the admin-check logic is implemented and deployed.,Code review of `userDeletion.handler.ts` shows the absence of an admin role check before deployment to an environment where admins might need to invoke it.,Security Lead,2024-09-22,Open
RISK-005,Technical,"The Firestore deletion logic uses a single batched write, which is limited to 500 operations. A 'power user' with more than 499 related documents (e.g., leaderboard entries) will cause the function to fail entirely, making it impossible to complete their deletion request.",2,4,8,Medium,WI-007,"Assumption that a user's data footprint will always be small enough to fit within the Firestore batch limit. Failure to account for edge cases and scalability.",Preventive: Refactor the `deleteUserDocuments` function to handle large amounts of data. It should query for documents to be deleted, and if the count exceeds a safe threshold (e.g., 450), it should process the deletions in multiple, sequential batches within a loop.,Corrective: If the function fails in production for this reason, an administrator will need to manually delete the user's data in chunks using a script or the Firebase Console.,Function logs show 'INVALID_ARGUMENT: A write batch can contain at most 500 operations' error.,Dev Lead,2024-09-15,Open
RISK-006,Quality,"Subtle behavioral differences between the Firebase Emulator Suite and the production environment could lead to tests passing locally but the function failing in production. This risk includes differences in IAM permission enforcement, indexing behavior, or SDK interactions.",3,4,12,Medium,"WI-014, WI-015","Over-reliance on emulators, which are simulations and not perfect replicas of the production cloud environment.",Detective: As part of the CI/CD pipeline, deploy the function to a dedicated staging Firebase project that mirrors production configuration. Run the integration test suite against this staging environment before deploying to production.,Corrective: Have a well-documented and practiced rollback procedure for the function. Ensure monitoring and alerting are configured to immediately notify the team of a spike in execution errors post-deployment.,A new version of the function is deployed and immediately begins reporting errors that were not present in emulator testing.,QA Lead,2024-09-25,Open
RISK-007,Resource,"The integration testing task (WI-015) is rated as 'High' complexity. A developer with insufficient experience in orchestrating the Firebase Emulator Suite via test scripts may face significant delays or produce flaky, unreliable tests, compromising quality assurance.",3,3,9,Medium,WI-015,"The inherent complexity of writing automated end-to-end tests that manage state across multiple emulated services (Auth, Firestore, Functions).",Preventive: Allocate time for paired programming with a senior developer on the integration test setup. Provide the developer with official Firebase documentation and example repositories for emulator-based testing.,Contingency: If the automated test proves to be a blocker for the release, a detailed manual test plan must be created and executed using the emulators as a temporary measure. The automated test will remain as a high-priority tech debt item.,The time spent on WI-015 exceeds its estimate by 50% without a working test in the pull request.,Dev Lead,2024-09-25,Open
RISK-008,Technical,"The Firestore query to find related data (e.g., `db.collection(""LeaderboardEntries"").where(""userId"", ""=="", uid)`) could be slow and costly at scale if the `userId` field is not indexed in the `LeaderboardEntries` collection.",3,3,9,Medium,WI-007,"Forgetting to define necessary database indexes for query patterns used in application code is a common oversight.",Preventive: As part of the infrastructure-as-code or development process, ensure that a corresponding Firestore index is defined for every query pattern used in the adapters. This should be part of the definition of done for the task.,Corrective: If high execution times are observed, use the Firebase console to identify slow queries and create the necessary index. The fix is typically fast, but performance will be degraded until it is applied.,Google Cloud Monitoring alerts on high latency for the `deleteUser` function, or cost analysis shows high read operations for Firestore.,DBA/Dev Lead,2024-09-15,Open
RISK-009,Operational,"The Cloud Function's runtime service account may lack the necessary IAM permissions (e.g., `firebaseauth.users.delete`, `datastore.user`) in the production GCP project, causing the function to fail with permission denied errors.",3,4,12,Medium,"WI-010, WI-011","Discrepancy between default permissions in a local/dev project and a more locked-down production project. Failure to provision infrastructure permissions alongside code deployment.",Preventive: Define the required IAM roles for the function's service account using an Infrastructure as Code tool (e.g., Terraform). The deployment pipeline should ensure these permissions are applied before the function code is deployed.,Corrective: Manually grant the required roles (`Firebase Authentication Admin`, `Cloud Datastore User`) to the function's service account in the GCP IAM console. Document this manual step and create a task to automate it.,Function logs show `PERMISSION_DENIED` errors when trying to access Firebase Auth or Firestore services.,DevOps Lead,2024-09-28,Open